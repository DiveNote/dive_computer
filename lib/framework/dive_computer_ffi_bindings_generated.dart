// ignore_for_file: always_specify_types, unused_field, unused_element
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;
import 'dart:ffi';

/// Regenerate bindings with `flutter pub run ffigen --config ffigen.yaml`.
///
class DiveComputerFfiBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  DiveComputerFfiBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  DiveComputerFfiBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  int dc_context_new(
    ffi.Pointer<ffi.Pointer<dc_context_t>> context,
  ) {
    return _dc_context_new(
      context,
    );
  }

  late final _dc_context_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<dc_context_t>>)>>('dc_context_new');
  late final _dc_context_new = _dc_context_newPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<dc_context_t>>)>();

  int dc_context_free(
    ffi.Pointer<dc_context_t> context,
  ) {
    return _dc_context_free(
      context,
    );
  }

  late final _dc_context_freePtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<dc_context_t>)>>(
      'dc_context_free');
  late final _dc_context_free =
      _dc_context_freePtr.asFunction<int Function(ffi.Pointer<dc_context_t>)>();

  int dc_context_set_loglevel(
    ffi.Pointer<dc_context_t> context,
    int loglevel,
  ) {
    return _dc_context_set_loglevel(
      context,
      loglevel,
    );
  }

  late final _dc_context_set_loglevelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<dc_context_t>,
              ffi.Int32)>>('dc_context_set_loglevel');
  late final _dc_context_set_loglevel = _dc_context_set_loglevelPtr
      .asFunction<int Function(ffi.Pointer<dc_context_t>, int)>();

  int dc_context_set_logfunc(
    ffi.Pointer<dc_context_t> context,
    dc_logfunc_t logfunc,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _dc_context_set_logfunc(
      context,
      logfunc,
      userdata,
    );
  }

  late final _dc_context_set_logfuncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<dc_context_t>, dc_logfunc_t,
              ffi.Pointer<ffi.Void>)>>('dc_context_set_logfunc');
  late final _dc_context_set_logfunc = _dc_context_set_logfuncPtr.asFunction<
      int Function(
          ffi.Pointer<dc_context_t>, dc_logfunc_t, ffi.Pointer<ffi.Void>)>();

  int dc_context_get_transports(
    ffi.Pointer<dc_context_t> context,
  ) {
    return _dc_context_get_transports(
      context,
    );
  }

  late final _dc_context_get_transportsPtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<dc_context_t>)>>(
      'dc_context_get_transports');
  late final _dc_context_get_transports = _dc_context_get_transportsPtr
      .asFunction<int Function(ffi.Pointer<dc_context_t>)>();

  int dc_iterator_next(
    ffi.Pointer<dc_iterator_t> iterator,
    ffi.Pointer<ffi.Void> item,
  ) {
    return _dc_iterator_next(
      iterator,
      item,
    );
  }

  late final _dc_iterator_nextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<dc_iterator_t>,
              ffi.Pointer<ffi.Void>)>>('dc_iterator_next');
  late final _dc_iterator_next = _dc_iterator_nextPtr.asFunction<
      int Function(ffi.Pointer<dc_iterator_t>, ffi.Pointer<ffi.Void>)>();

  int dc_iterator_free(
    ffi.Pointer<dc_iterator_t> iterator,
  ) {
    return _dc_iterator_free(
      iterator,
    );
  }

  late final _dc_iterator_freePtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<dc_iterator_t>)>>(
      'dc_iterator_free');
  late final _dc_iterator_free = _dc_iterator_freePtr
      .asFunction<int Function(ffi.Pointer<dc_iterator_t>)>();

  /// Create an iterator to enumerate the supported dive computers.
  ///
  /// @param[out] iterator  A location to store the iterator.
  /// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
  /// on failure.
  int dc_descriptor_iterator(
    ffi.Pointer<ffi.Pointer<dc_iterator_t>> iterator,
  ) {
    return _dc_descriptor_iterator(
      iterator,
    );
  }

  late final _dc_descriptor_iteratorPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ffi.Pointer<dc_iterator_t>>)>>(
      'dc_descriptor_iterator');
  late final _dc_descriptor_iterator = _dc_descriptor_iteratorPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<dc_iterator_t>>)>();

  /// Free the device descriptor.
  ///
  /// @param[in]  descriptor  A valid device descriptor.
  void dc_descriptor_free(
    ffi.Pointer<dc_descriptor_t> descriptor,
  ) {
    return _dc_descriptor_free(
      descriptor,
    );
  }

  late final _dc_descriptor_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<dc_descriptor_t>)>>(
      'dc_descriptor_free');
  late final _dc_descriptor_free = _dc_descriptor_freePtr
      .asFunction<void Function(ffi.Pointer<dc_descriptor_t>)>();

  /// Get the vendor name of the dive computer.
  ///
  /// @param[in]  descriptor  A valid device descriptor.
  /// @returns The vendor name of the dive computer on success, or NULL on failure.
  ffi.Pointer<ffi.Char> dc_descriptor_get_vendor(
    ffi.Pointer<dc_descriptor_t> descriptor,
  ) {
    return _dc_descriptor_get_vendor(
      descriptor,
    );
  }

  late final _dc_descriptor_get_vendorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<dc_descriptor_t>)>>('dc_descriptor_get_vendor');
  late final _dc_descriptor_get_vendor =
      _dc_descriptor_get_vendorPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<dc_descriptor_t>)>();

  /// Get the product name of the dive computer.
  ///
  /// @param[in]  descriptor  A valid device descriptor.
  /// @returns The product name of the dive computer on success, or NULL on
  /// failure.
  ffi.Pointer<ffi.Char> dc_descriptor_get_product(
    ffi.Pointer<dc_descriptor_t> descriptor,
  ) {
    return _dc_descriptor_get_product(
      descriptor,
    );
  }

  late final _dc_descriptor_get_productPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<dc_descriptor_t>)>>('dc_descriptor_get_product');
  late final _dc_descriptor_get_product =
      _dc_descriptor_get_productPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<dc_descriptor_t>)>();

  /// Get the family type of the dive computer.
  ///
  /// @param[in]  descriptor  A valid device descriptor.
  /// @returns The family type of the dive computer on success, or DC_FAMILY_NULL
  /// on failure.
  int dc_descriptor_get_type(
    ffi.Pointer<dc_descriptor_t> descriptor,
  ) {
    return _dc_descriptor_get_type(
      descriptor,
    );
  }

  late final _dc_descriptor_get_typePtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<dc_descriptor_t>)>>(
      'dc_descriptor_get_type');
  late final _dc_descriptor_get_type = _dc_descriptor_get_typePtr
      .asFunction<int Function(ffi.Pointer<dc_descriptor_t>)>();

  /// Get the model number of the dive computer.
  ///
  /// @param[in]  descriptor  A valid device descriptor.
  /// @returns The model number of the dive computer on success, or zero on
  /// failure.
  int dc_descriptor_get_model(
    ffi.Pointer<dc_descriptor_t> descriptor,
  ) {
    return _dc_descriptor_get_model(
      descriptor,
    );
  }

  late final _dc_descriptor_get_modelPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<dc_descriptor_t>)>>('dc_descriptor_get_model');
  late final _dc_descriptor_get_model = _dc_descriptor_get_modelPtr
      .asFunction<int Function(ffi.Pointer<dc_descriptor_t>)>();

  /// Get all transports supported by the dive computer.
  ///
  /// @param[in]  descriptor  A valid device descriptor.
  /// @returns A bitmask with all the transports supported by the dive computer on
  /// success, or DC_TRANSPORT_NONE on failure.
  int dc_descriptor_get_transports(
    ffi.Pointer<dc_descriptor_t> descriptor,
  ) {
    return _dc_descriptor_get_transports(
      descriptor,
    );
  }

  late final _dc_descriptor_get_transportsPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<dc_descriptor_t>)>>('dc_descriptor_get_transports');
  late final _dc_descriptor_get_transports = _dc_descriptor_get_transportsPtr
      .asFunction<int Function(ffi.Pointer<dc_descriptor_t>)>();

  /// Check if a low-level I/O device matches a supported dive computer.
  ///
  /// @param[in]  descriptor  A valid device descriptor.
  /// @param[in]  transport   The transport type of the I/O device.
  /// @param[in]  userdata    A pointer to a transport specific data structure:
  /// - DC_TRANSPORT_SERIAL:    Name of the device node (string)
  /// - DC_TRANSPORT_USB:       USB VID/PID (#dc_usb_desc_t)
  /// - DC_TRANSPORT_USBHID:    USB VID/PID (#dc_usbhid_desc_t)
  /// - DC_TRANSPORT_IRDA:      IrDA device name (string)
  /// - DC_TRANSPORT_BLUETOOTH: Bluetooth device name (string)
  /// - DC_TRANSPORT_BLE:       Bluetooth device name (string)
  /// @returns Non-zero if the device matches a supported dive computer, or zero if
  /// there is no match.
  int dc_descriptor_filter(
    ffi.Pointer<dc_descriptor_t> descriptor,
    int transport,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _dc_descriptor_filter(
      descriptor,
      transport,
      userdata,
    );
  }

  late final _dc_descriptor_filterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<dc_descriptor_t>, ffi.Int32,
              ffi.Pointer<ffi.Void>)>>('dc_descriptor_filter');
  late final _dc_descriptor_filter = _dc_descriptor_filterPtr.asFunction<
      int Function(ffi.Pointer<dc_descriptor_t>, int, ffi.Pointer<ffi.Void>)>();

  /// Get the transport type.
  ///
  /// @param[in]  iostream  A valid I/O stream.
  /// @returns The transport type of the I/O stream.
  int dc_iostream_get_transport(
    ffi.Pointer<dc_iostream_t> iostream,
  ) {
    return _dc_iostream_get_transport(
      iostream,
    );
  }

  late final _dc_iostream_get_transportPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<dc_iostream_t>)>>(
      'dc_iostream_get_transport');
  late final _dc_iostream_get_transport = _dc_iostream_get_transportPtr
      .asFunction<int Function(ffi.Pointer<dc_iostream_t>)>();

  /// Set the read timeout.
  ///
  /// There are three distinct modes available:
  ///
  /// 1. Blocking (timeout < 0):
  ///
  /// The read operation is blocked until all the requested bytes have
  /// been received. If the requested number of bytes does not arrive,
  /// the operation will block forever.
  ///
  /// 2. Non-blocking (timeout == 0):
  ///
  /// The read operation returns immediately with the bytes that have
  /// already been received, even if no bytes have been received.
  ///
  /// 3. Timeout (timeout > 0):
  ///
  /// The read operation is blocked until all the requested bytes have
  /// been received. If the requested number of bytes does not arrive
  /// within the specified amount of time, the operation will return
  /// with the bytes that have already been received.
  ///
  /// @param[in]  iostream  A valid I/O stream.
  /// @param[in]  timeout   The timeout in milliseconds.
  /// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
  /// on failure.
  int dc_iostream_set_timeout(
    ffi.Pointer<dc_iostream_t> iostream,
    int timeout,
  ) {
    return _dc_iostream_set_timeout(
      iostream,
      timeout,
    );
  }

  late final _dc_iostream_set_timeoutPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<dc_iostream_t>, ffi.Int)>>('dc_iostream_set_timeout');
  late final _dc_iostream_set_timeout = _dc_iostream_set_timeoutPtr
      .asFunction<int Function(ffi.Pointer<dc_iostream_t>, int)>();

  /// Set the state of the break condition.
  ///
  /// @param[in]  iostream  A valid I/O stream.
  /// @param[in]  value     The break condition state.
  /// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
  /// on failure.
  int dc_iostream_set_break(
    ffi.Pointer<dc_iostream_t> iostream,
    int value,
  ) {
    return _dc_iostream_set_break(
      iostream,
      value,
    );
  }

  late final _dc_iostream_set_breakPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<dc_iostream_t>,
              ffi.UnsignedInt)>>('dc_iostream_set_break');
  late final _dc_iostream_set_break = _dc_iostream_set_breakPtr
      .asFunction<int Function(ffi.Pointer<dc_iostream_t>, int)>();

  /// Set the state of the DTR line.
  ///
  /// @param[in]  iostream  A valid I/O stream.
  /// @param[in]  value     The DTR line state.
  /// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
  /// on failure.
  int dc_iostream_set_dtr(
    ffi.Pointer<dc_iostream_t> iostream,
    int value,
  ) {
    return _dc_iostream_set_dtr(
      iostream,
      value,
    );
  }

  late final _dc_iostream_set_dtrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<dc_iostream_t>,
              ffi.UnsignedInt)>>('dc_iostream_set_dtr');
  late final _dc_iostream_set_dtr = _dc_iostream_set_dtrPtr
      .asFunction<int Function(ffi.Pointer<dc_iostream_t>, int)>();

  /// Set the state of the RTS line.
  ///
  /// @param[in]  iostream  A valid I/O stream.
  /// @param[in]  value     The RTS line state.
  /// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
  /// on failure.
  int dc_iostream_set_rts(
    ffi.Pointer<dc_iostream_t> iostream,
    int value,
  ) {
    return _dc_iostream_set_rts(
      iostream,
      value,
    );
  }

  late final _dc_iostream_set_rtsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<dc_iostream_t>,
              ffi.UnsignedInt)>>('dc_iostream_set_rts');
  late final _dc_iostream_set_rts = _dc_iostream_set_rtsPtr
      .asFunction<int Function(ffi.Pointer<dc_iostream_t>, int)>();

  /// Query the state of the line signals.
  ///
  /// @param[in]   iostream  A valid I/O stream.
  /// @param[out]  value     A location to store the bitmap with the state
  /// of the line signals.
  /// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
  /// on failure.
  int dc_iostream_get_lines(
    ffi.Pointer<dc_iostream_t> iostream,
    ffi.Pointer<ffi.UnsignedInt> value,
  ) {
    return _dc_iostream_get_lines(
      iostream,
      value,
    );
  }

  late final _dc_iostream_get_linesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<dc_iostream_t>,
              ffi.Pointer<ffi.UnsignedInt>)>>('dc_iostream_get_lines');
  late final _dc_iostream_get_lines = _dc_iostream_get_linesPtr.asFunction<
      int Function(ffi.Pointer<dc_iostream_t>, ffi.Pointer<ffi.UnsignedInt>)>();

  /// Query the number of available bytes in the input buffer.
  ///
  /// @param[in]   iostream  A valid I/O stream.
  /// @param[out]  value     A location to store the number of bytes in the
  /// input buffer.
  /// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
  /// on failure.
  int dc_iostream_get_available(
    ffi.Pointer<dc_iostream_t> iostream,
    ffi.Pointer<ffi.Size> value,
  ) {
    return _dc_iostream_get_available(
      iostream,
      value,
    );
  }

  late final _dc_iostream_get_availablePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<dc_iostream_t>,
              ffi.Pointer<ffi.Size>)>>('dc_iostream_get_available');
  late final _dc_iostream_get_available =
      _dc_iostream_get_availablePtr.asFunction<
          int Function(ffi.Pointer<dc_iostream_t>, ffi.Pointer<ffi.Size>)>();

  /// Configure the line settings.
  ///
  /// @param[in]  iostream     A valid I/O stream.
  /// @param[in]  baudrate     The baud rate setting.
  /// @param[in]  databits     The number of data bits.
  /// @param[in]  parity       The parity setting.
  /// @param[in]  stopbits     The number of stop bits.
  /// @param[in]  flowcontrol  The flow control setting.
  /// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
  /// on failure.
  int dc_iostream_configure(
    ffi.Pointer<dc_iostream_t> iostream,
    int baudrate,
    int databits,
    int parity,
    int stopbits,
    int flowcontrol,
  ) {
    return _dc_iostream_configure(
      iostream,
      baudrate,
      databits,
      parity,
      stopbits,
      flowcontrol,
    );
  }

  late final _dc_iostream_configurePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<dc_iostream_t>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32)>>('dc_iostream_configure');
  late final _dc_iostream_configure = _dc_iostream_configurePtr.asFunction<
      int Function(ffi.Pointer<dc_iostream_t>, int, int, int, int, int)>();

  /// Poll the I/O stream for available data.
  ///
  /// There are three distinct modes available:
  ///
  /// 1. Blocking (timeout < 0):
  ///
  /// The poll operation is blocked until one or more bytes have been
  /// received. If no bytes are received, the operation will block
  /// forever.
  ///
  /// 2. Non-blocking (timeout == 0):
  ///
  /// The poll operation returns immediately, even if no bytes have
  /// been received.
  ///
  /// 3. Timeout (timeout > 0):
  ///
  /// The poll operation is blocked until one or more bytes have been
  /// received. If no bytes are received within the specified amount of
  /// time, the operation will return with a timeout.
  ///
  /// @param[in]  iostream  A valid I/O stream.
  /// @param[in]  timeout   The timeout in milliseconds.
  /// @returns #DC_STATUS_SUCCESS on success, #DC_STATUS_TIMEOUT on
  /// timeout, or another #dc_status_t code on failure.
  int dc_iostream_poll(
    ffi.Pointer<dc_iostream_t> iostream,
    int timeout,
  ) {
    return _dc_iostream_poll(
      iostream,
      timeout,
    );
  }

  late final _dc_iostream_pollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<dc_iostream_t>, ffi.Int)>>('dc_iostream_poll');
  late final _dc_iostream_poll = _dc_iostream_pollPtr
      .asFunction<int Function(ffi.Pointer<dc_iostream_t>, int)>();

  /// Read data from the I/O stream.
  ///
  /// @param[in]  iostream  A valid I/O stream.
  /// @param[out] data      The memory buffer to read the data into.
  /// @param[in]  size      The number of bytes to read.
  /// @param[out] actual    An (optional) location to store the actual
  /// number of bytes transferred.
  /// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
  /// on failure.
  int dc_iostream_read(
    ffi.Pointer<dc_iostream_t> iostream,
    ffi.Pointer<ffi.Void> data,
    int size,
    ffi.Pointer<ffi.Size> actual,
  ) {
    return _dc_iostream_read(
      iostream,
      data,
      size,
      actual,
    );
  }

  late final _dc_iostream_readPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<dc_iostream_t>, ffi.Pointer<ffi.Void>,
              ffi.Size, ffi.Pointer<ffi.Size>)>>('dc_iostream_read');
  late final _dc_iostream_read = _dc_iostream_readPtr.asFunction<
      int Function(ffi.Pointer<dc_iostream_t>, ffi.Pointer<ffi.Void>, int,
          ffi.Pointer<ffi.Size>)>();

  /// Write data to the I/O stream.
  ///
  /// @param[in]  iostream  A valid I/O stream.
  /// @param[in]  data      The memory buffer to write the data from.
  /// @param[in]  size      The number of bytes to write.
  /// @param[out] actual    An (optional) location to store the actual
  /// number of bytes transferred.
  /// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
  /// on failure.
  int dc_iostream_write(
    ffi.Pointer<dc_iostream_t> iostream,
    ffi.Pointer<ffi.Void> data,
    int size,
    ffi.Pointer<ffi.Size> actual,
  ) {
    return _dc_iostream_write(
      iostream,
      data,
      size,
      actual,
    );
  }

  late final _dc_iostream_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<dc_iostream_t>, ffi.Pointer<ffi.Void>,
              ffi.Size, ffi.Pointer<ffi.Size>)>>('dc_iostream_write');
  late final _dc_iostream_write = _dc_iostream_writePtr.asFunction<
      int Function(ffi.Pointer<dc_iostream_t>, ffi.Pointer<ffi.Void>, int,
          ffi.Pointer<ffi.Size>)>();

  /// Perform an I/O stream specific request.
  ///
  /// @param[in]  iostream  A valid I/O stream.
  /// @param[in]  request   The request to perform.
  /// @param[in,out]  data  The request specific data.
  /// @param[in]  size      The size of the request specific data.
  /// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
  /// on failure.
  int dc_iostream_ioctl(
    ffi.Pointer<dc_iostream_t> iostream,
    int request,
    ffi.Pointer<ffi.Void> data,
    int size,
  ) {
    return _dc_iostream_ioctl(
      iostream,
      request,
      data,
      size,
    );
  }

  late final _dc_iostream_ioctlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<dc_iostream_t>, ffi.UnsignedInt,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('dc_iostream_ioctl');
  late final _dc_iostream_ioctl = _dc_iostream_ioctlPtr.asFunction<
      int Function(
          ffi.Pointer<dc_iostream_t>, int, ffi.Pointer<ffi.Void>, int)>();

  /// Flush the internal output buffer and wait until the data has been
  /// transmitted.
  ///
  /// @param[in]  iostream  A valid I/O stream.
  /// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
  /// on failure.
  int dc_iostream_flush(
    ffi.Pointer<dc_iostream_t> iostream,
  ) {
    return _dc_iostream_flush(
      iostream,
    );
  }

  late final _dc_iostream_flushPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<dc_iostream_t>)>>(
      'dc_iostream_flush');
  late final _dc_iostream_flush = _dc_iostream_flushPtr
      .asFunction<int Function(ffi.Pointer<dc_iostream_t>)>();

  /// Discards all data from the internal buffers.
  ///
  /// @param[in]  iostream   A valid I/O stream.
  /// @param[in]  direction  The direction of the buffer(s).
  /// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
  /// on failure.
  int dc_iostream_purge(
    ffi.Pointer<dc_iostream_t> iostream,
    int direction,
  ) {
    return _dc_iostream_purge(
      iostream,
      direction,
    );
  }

  late final _dc_iostream_purgePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<dc_iostream_t>, ffi.Int32)>>('dc_iostream_purge');
  late final _dc_iostream_purge = _dc_iostream_purgePtr
      .asFunction<int Function(ffi.Pointer<dc_iostream_t>, int)>();

  /// Suspend execution of the current thread for the specified amount of
  /// time.
  ///
  /// @param[in]  iostream      A valid I/O stream.
  /// @param[in]  milliseconds  The number of milliseconds to sleep.
  /// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
  /// on failure.
  int dc_iostream_sleep(
    ffi.Pointer<dc_iostream_t> iostream,
    int milliseconds,
  ) {
    return _dc_iostream_sleep(
      iostream,
      milliseconds,
    );
  }

  late final _dc_iostream_sleepPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<dc_iostream_t>,
              ffi.UnsignedInt)>>('dc_iostream_sleep');
  late final _dc_iostream_sleep = _dc_iostream_sleepPtr
      .asFunction<int Function(ffi.Pointer<dc_iostream_t>, int)>();

  /// Close the I/O stream and free all resources.
  ///
  /// @param[in]  iostream  A valid I/O stream.
  /// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
  /// on failure.
  int dc_iostream_close(
    ffi.Pointer<dc_iostream_t> iostream,
  ) {
    return _dc_iostream_close(
      iostream,
    );
  }

  late final _dc_iostream_closePtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<dc_iostream_t>)>>(
      'dc_iostream_close');
  late final _dc_iostream_close = _dc_iostream_closePtr
      .asFunction<int Function(ffi.Pointer<dc_iostream_t>)>();

  ffi.Pointer<dc_buffer_t> dc_buffer_new(
    int capacity,
  ) {
    return _dc_buffer_new(
      capacity,
    );
  }

  late final _dc_buffer_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<dc_buffer_t> Function(ffi.Size)>>(
          'dc_buffer_new');
  late final _dc_buffer_new =
      _dc_buffer_newPtr.asFunction<ffi.Pointer<dc_buffer_t> Function(int)>();

  void dc_buffer_free(
    ffi.Pointer<dc_buffer_t> buffer,
  ) {
    return _dc_buffer_free(
      buffer,
    );
  }

  late final _dc_buffer_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<dc_buffer_t>)>>(
          'dc_buffer_free');
  late final _dc_buffer_free =
      _dc_buffer_freePtr.asFunction<void Function(ffi.Pointer<dc_buffer_t>)>();

  int dc_buffer_clear(
    ffi.Pointer<dc_buffer_t> buffer,
  ) {
    return _dc_buffer_clear(
      buffer,
    );
  }

  late final _dc_buffer_clearPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<dc_buffer_t>)>>(
          'dc_buffer_clear');
  late final _dc_buffer_clear =
      _dc_buffer_clearPtr.asFunction<int Function(ffi.Pointer<dc_buffer_t>)>();

  int dc_buffer_reserve(
    ffi.Pointer<dc_buffer_t> buffer,
    int capacity,
  ) {
    return _dc_buffer_reserve(
      buffer,
      capacity,
    );
  }

  late final _dc_buffer_reservePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<dc_buffer_t>, ffi.Size)>>('dc_buffer_reserve');
  late final _dc_buffer_reserve = _dc_buffer_reservePtr
      .asFunction<int Function(ffi.Pointer<dc_buffer_t>, int)>();

  int dc_buffer_resize(
    ffi.Pointer<dc_buffer_t> buffer,
    int size,
  ) {
    return _dc_buffer_resize(
      buffer,
      size,
    );
  }

  late final _dc_buffer_resizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<dc_buffer_t>, ffi.Size)>>('dc_buffer_resize');
  late final _dc_buffer_resize = _dc_buffer_resizePtr
      .asFunction<int Function(ffi.Pointer<dc_buffer_t>, int)>();

  int dc_buffer_append(
    ffi.Pointer<dc_buffer_t> buffer,
    ffi.Pointer<ffi.UnsignedChar> data,
    int size,
  ) {
    return _dc_buffer_append(
      buffer,
      data,
      size,
    );
  }

  late final _dc_buffer_appendPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<dc_buffer_t>,
              ffi.Pointer<ffi.UnsignedChar>, ffi.Size)>>('dc_buffer_append');
  late final _dc_buffer_append = _dc_buffer_appendPtr.asFunction<
      int Function(
          ffi.Pointer<dc_buffer_t>, ffi.Pointer<ffi.UnsignedChar>, int)>();

  int dc_buffer_prepend(
    ffi.Pointer<dc_buffer_t> buffer,
    ffi.Pointer<ffi.UnsignedChar> data,
    int size,
  ) {
    return _dc_buffer_prepend(
      buffer,
      data,
      size,
    );
  }

  late final _dc_buffer_prependPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<dc_buffer_t>,
              ffi.Pointer<ffi.UnsignedChar>, ffi.Size)>>('dc_buffer_prepend');
  late final _dc_buffer_prepend = _dc_buffer_prependPtr.asFunction<
      int Function(
          ffi.Pointer<dc_buffer_t>, ffi.Pointer<ffi.UnsignedChar>, int)>();

  int dc_buffer_insert(
    ffi.Pointer<dc_buffer_t> buffer,
    int offset,
    ffi.Pointer<ffi.UnsignedChar> data,
    int size,
  ) {
    return _dc_buffer_insert(
      buffer,
      offset,
      data,
      size,
    );
  }

  late final _dc_buffer_insertPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<dc_buffer_t>, ffi.Size,
              ffi.Pointer<ffi.UnsignedChar>, ffi.Size)>>('dc_buffer_insert');
  late final _dc_buffer_insert = _dc_buffer_insertPtr.asFunction<
      int Function(
          ffi.Pointer<dc_buffer_t>, int, ffi.Pointer<ffi.UnsignedChar>, int)>();

  int dc_buffer_slice(
    ffi.Pointer<dc_buffer_t> buffer,
    int offset,
    int size,
  ) {
    return _dc_buffer_slice(
      buffer,
      offset,
      size,
    );
  }

  late final _dc_buffer_slicePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<dc_buffer_t>, ffi.Size,
              ffi.Size)>>('dc_buffer_slice');
  late final _dc_buffer_slice = _dc_buffer_slicePtr
      .asFunction<int Function(ffi.Pointer<dc_buffer_t>, int, int)>();

  int dc_buffer_get_size(
    ffi.Pointer<dc_buffer_t> buffer,
  ) {
    return _dc_buffer_get_size(
      buffer,
    );
  }

  late final _dc_buffer_get_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<dc_buffer_t>)>>(
          'dc_buffer_get_size');
  late final _dc_buffer_get_size = _dc_buffer_get_sizePtr
      .asFunction<int Function(ffi.Pointer<dc_buffer_t>)>();

  ffi.Pointer<ffi.UnsignedChar> dc_buffer_get_data(
    ffi.Pointer<dc_buffer_t> buffer,
  ) {
    return _dc_buffer_get_data(
      buffer,
    );
  }

  late final _dc_buffer_get_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedChar> Function(
              ffi.Pointer<dc_buffer_t>)>>('dc_buffer_get_data');
  late final _dc_buffer_get_data = _dc_buffer_get_dataPtr.asFunction<
      ffi.Pointer<ffi.UnsignedChar> Function(ffi.Pointer<dc_buffer_t>)>();

  int dc_datetime_now() {
    return _dc_datetime_now();
  }

  late final _dc_datetime_nowPtr =
      _lookup<ffi.NativeFunction<dc_ticks_t Function()>>('dc_datetime_now');
  late final _dc_datetime_now =
      _dc_datetime_nowPtr.asFunction<int Function()>();

  ffi.Pointer<dc_datetime_t> dc_datetime_localtime(
    ffi.Pointer<dc_datetime_t> result,
    int ticks,
  ) {
    return _dc_datetime_localtime(
      result,
      ticks,
    );
  }

  late final _dc_datetime_localtimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<dc_datetime_t> Function(ffi.Pointer<dc_datetime_t>,
              dc_ticks_t)>>('dc_datetime_localtime');
  late final _dc_datetime_localtime = _dc_datetime_localtimePtr.asFunction<
      ffi.Pointer<dc_datetime_t> Function(ffi.Pointer<dc_datetime_t>, int)>();

  ffi.Pointer<dc_datetime_t> dc_datetime_gmtime(
    ffi.Pointer<dc_datetime_t> result,
    int ticks,
  ) {
    return _dc_datetime_gmtime(
      result,
      ticks,
    );
  }

  late final _dc_datetime_gmtimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<dc_datetime_t> Function(
              ffi.Pointer<dc_datetime_t>, dc_ticks_t)>>('dc_datetime_gmtime');
  late final _dc_datetime_gmtime = _dc_datetime_gmtimePtr.asFunction<
      ffi.Pointer<dc_datetime_t> Function(ffi.Pointer<dc_datetime_t>, int)>();

  int dc_datetime_mktime(
    ffi.Pointer<dc_datetime_t> dt,
  ) {
    return _dc_datetime_mktime(
      dt,
    );
  }

  late final _dc_datetime_mktimePtr = _lookup<
          ffi.NativeFunction<dc_ticks_t Function(ffi.Pointer<dc_datetime_t>)>>(
      'dc_datetime_mktime');
  late final _dc_datetime_mktime = _dc_datetime_mktimePtr
      .asFunction<int Function(ffi.Pointer<dc_datetime_t>)>();

  int dc_device_open(
    ffi.Pointer<ffi.Pointer<dc_device_t>> out,
    ffi.Pointer<dc_context_t> context,
    ffi.Pointer<dc_descriptor_t> descriptor,
    ffi.Pointer<dc_iostream_t> iostream,
  ) {
    return _dc_device_open(
      out,
      context,
      descriptor,
      iostream,
    );
  }

  late final _dc_device_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<dc_device_t>>,
              ffi.Pointer<dc_context_t>,
              ffi.Pointer<dc_descriptor_t>,
              ffi.Pointer<dc_iostream_t>)>>('dc_device_open');
  late final _dc_device_open = _dc_device_openPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<dc_device_t>>,
          ffi.Pointer<dc_context_t>,
          ffi.Pointer<dc_descriptor_t>,
          ffi.Pointer<dc_iostream_t>)>();

  int dc_device_get_type(
    ffi.Pointer<dc_device_t> device,
  ) {
    return _dc_device_get_type(
      device,
    );
  }

  late final _dc_device_get_typePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<dc_device_t>)>>(
          'dc_device_get_type');
  late final _dc_device_get_type = _dc_device_get_typePtr
      .asFunction<int Function(ffi.Pointer<dc_device_t>)>();

  int dc_device_set_cancel(
    ffi.Pointer<dc_device_t> device,
    dc_cancel_callback_t callback,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _dc_device_set_cancel(
      device,
      callback,
      userdata,
    );
  }

  late final _dc_device_set_cancelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<dc_device_t>, dc_cancel_callback_t,
              ffi.Pointer<ffi.Void>)>>('dc_device_set_cancel');
  late final _dc_device_set_cancel = _dc_device_set_cancelPtr.asFunction<
      int Function(ffi.Pointer<dc_device_t>, dc_cancel_callback_t,
          ffi.Pointer<ffi.Void>)>();

  int dc_device_set_events(
    ffi.Pointer<dc_device_t> device,
    int events,
    dc_event_callback_t callback,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _dc_device_set_events(
      device,
      events,
      callback,
      userdata,
    );
  }

  late final _dc_device_set_eventsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<dc_device_t>,
              ffi.UnsignedInt,
              dc_event_callback_t,
              ffi.Pointer<ffi.Void>)>>('dc_device_set_events');
  late final _dc_device_set_events = _dc_device_set_eventsPtr.asFunction<
      int Function(ffi.Pointer<dc_device_t>, int, dc_event_callback_t,
          ffi.Pointer<ffi.Void>)>();

  int dc_device_set_fingerprint(
    ffi.Pointer<dc_device_t> device,
    ffi.Pointer<ffi.UnsignedChar> data,
    int size,
  ) {
    return _dc_device_set_fingerprint(
      device,
      data,
      size,
    );
  }

  late final _dc_device_set_fingerprintPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<dc_device_t>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.UnsignedInt)>>('dc_device_set_fingerprint');
  late final _dc_device_set_fingerprint =
      _dc_device_set_fingerprintPtr.asFunction<
          int Function(
              ffi.Pointer<dc_device_t>, ffi.Pointer<ffi.UnsignedChar>, int)>();

  int dc_device_read(
    ffi.Pointer<dc_device_t> device,
    int address,
    ffi.Pointer<ffi.UnsignedChar> data,
    int size,
  ) {
    return _dc_device_read(
      device,
      address,
      data,
      size,
    );
  }

  late final _dc_device_readPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<dc_device_t>,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.UnsignedInt)>>('dc_device_read');
  late final _dc_device_read = _dc_device_readPtr.asFunction<
      int Function(
          ffi.Pointer<dc_device_t>, int, ffi.Pointer<ffi.UnsignedChar>, int)>();

  int dc_device_write(
    ffi.Pointer<dc_device_t> device,
    int address,
    ffi.Pointer<ffi.UnsignedChar> data,
    int size,
  ) {
    return _dc_device_write(
      device,
      address,
      data,
      size,
    );
  }

  late final _dc_device_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<dc_device_t>,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.UnsignedInt)>>('dc_device_write');
  late final _dc_device_write = _dc_device_writePtr.asFunction<
      int Function(
          ffi.Pointer<dc_device_t>, int, ffi.Pointer<ffi.UnsignedChar>, int)>();

  int dc_device_dump(
    ffi.Pointer<dc_device_t> device,
    ffi.Pointer<dc_buffer_t> buffer,
  ) {
    return _dc_device_dump(
      device,
      buffer,
    );
  }

  late final _dc_device_dumpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<dc_device_t>,
              ffi.Pointer<dc_buffer_t>)>>('dc_device_dump');
  late final _dc_device_dump = _dc_device_dumpPtr.asFunction<
      int Function(ffi.Pointer<dc_device_t>, ffi.Pointer<dc_buffer_t>)>();

  int dc_device_foreach(
    ffi.Pointer<dc_device_t> device,
    dc_dive_callback_t callback,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _dc_device_foreach(
      device,
      callback,
      userdata,
    );
  }

  late final _dc_device_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<dc_device_t>, dc_dive_callback_t,
              ffi.Pointer<ffi.Void>)>>('dc_device_foreach');
  late final _dc_device_foreach = _dc_device_foreachPtr.asFunction<
      int Function(ffi.Pointer<dc_device_t>, dc_dive_callback_t,
          ffi.Pointer<ffi.Void>)>();

  int dc_device_timesync(
    ffi.Pointer<dc_device_t> device,
    ffi.Pointer<dc_datetime_t> datetime,
  ) {
    return _dc_device_timesync(
      device,
      datetime,
    );
  }

  late final _dc_device_timesyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<dc_device_t>,
              ffi.Pointer<dc_datetime_t>)>>('dc_device_timesync');
  late final _dc_device_timesync = _dc_device_timesyncPtr.asFunction<
      int Function(ffi.Pointer<dc_device_t>, ffi.Pointer<dc_datetime_t>)>();

  int dc_device_close(
    ffi.Pointer<dc_device_t> device,
  ) {
    return _dc_device_close(
      device,
    );
  }

  late final _dc_device_closePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<dc_device_t>)>>(
          'dc_device_close');
  late final _dc_device_close =
      _dc_device_closePtr.asFunction<int Function(ffi.Pointer<dc_device_t>)>();

  /// Get the device node of the serial device.
  ///
  /// @param[in]  device  A valid serial device.
  ffi.Pointer<ffi.Char> dc_serial_device_get_name(
    ffi.Pointer<dc_serial_device_t> device,
  ) {
    return _dc_serial_device_get_name(
      device,
    );
  }

  late final _dc_serial_device_get_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<dc_serial_device_t>)>>('dc_serial_device_get_name');
  late final _dc_serial_device_get_name =
      _dc_serial_device_get_namePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<dc_serial_device_t>)>();

  /// Destroy the serial device and free all resources.
  ///
  /// @param[in]  device  A valid serial device.
  void dc_serial_device_free(
    ffi.Pointer<dc_serial_device_t> device,
  ) {
    return _dc_serial_device_free(
      device,
    );
  }

  late final _dc_serial_device_freePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<dc_serial_device_t>)>>(
      'dc_serial_device_free');
  late final _dc_serial_device_free = _dc_serial_device_freePtr
      .asFunction<void Function(ffi.Pointer<dc_serial_device_t>)>();

  /// Create an iterator to enumerate the serial devices.
  ///
  /// @param[out] iterator    A location to store the iterator.
  /// @param[in]  context     A valid context object.
  /// @param[in]  descriptor  A valid device descriptor or NULL.
  /// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
  /// on failure.
  int dc_serial_iterator_new(
    ffi.Pointer<ffi.Pointer<dc_iterator_t>> iterator,
    ffi.Pointer<dc_context_t> context,
    ffi.Pointer<dc_descriptor_t> descriptor,
  ) {
    return _dc_serial_iterator_new(
      iterator,
      context,
      descriptor,
    );
  }

  late final _dc_serial_iterator_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<dc_iterator_t>>,
              ffi.Pointer<dc_context_t>,
              ffi.Pointer<dc_descriptor_t>)>>('dc_serial_iterator_new');
  late final _dc_serial_iterator_new = _dc_serial_iterator_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<dc_iterator_t>>,
          ffi.Pointer<dc_context_t>, ffi.Pointer<dc_descriptor_t>)>();

  /// Open a serial connection.
  ///
  /// @param[out]  iostream A location to store the serial connection.
  /// @param[in]   context  A valid context object.
  /// @param[in]   name     The name of the device node.
  /// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
  /// on failure.
  int dc_serial_open(
    ffi.Pointer<ffi.Pointer<dc_iostream_t>> iostream,
    ffi.Pointer<dc_context_t> context,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _dc_serial_open(
      iostream,
      context,
      name,
    );
  }

  late final _dc_serial_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<dc_iostream_t>>,
              ffi.Pointer<dc_context_t>,
              ffi.Pointer<ffi.Char>)>>('dc_serial_open');
  late final _dc_serial_open = _dc_serial_openPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<dc_iostream_t>>,
          ffi.Pointer<dc_context_t>, ffi.Pointer<ffi.Char>)>();

  int dc_parser_new(
    ffi.Pointer<ffi.Pointer<dc_parser_t>> parser,
    ffi.Pointer<dc_device_t> device,
    ffi.Pointer<ffi.UnsignedChar> data,
    int size,
  ) {
    return _dc_parser_new(
      parser,
      device,
      data,
      size,
    );
  }

  late final _dc_parser_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<dc_parser_t>>,
              ffi.Pointer<dc_device_t>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Size)>>('dc_parser_new');
  late final _dc_parser_new = _dc_parser_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<dc_parser_t>>,
          ffi.Pointer<dc_device_t>, ffi.Pointer<ffi.UnsignedChar>, int)>();

  int dc_parser_new2(
    ffi.Pointer<ffi.Pointer<dc_parser_t>> parser,
    ffi.Pointer<dc_context_t> context,
    ffi.Pointer<dc_descriptor_t> descriptor,
    ffi.Pointer<ffi.UnsignedChar> data,
    int size,
  ) {
    return _dc_parser_new2(
      parser,
      context,
      descriptor,
      data,
      size,
    );
  }

  late final _dc_parser_new2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<dc_parser_t>>,
              ffi.Pointer<dc_context_t>,
              ffi.Pointer<dc_descriptor_t>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Size)>>('dc_parser_new2');
  late final _dc_parser_new2 = _dc_parser_new2Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<dc_parser_t>>,
          ffi.Pointer<dc_context_t>,
          ffi.Pointer<dc_descriptor_t>,
          ffi.Pointer<ffi.UnsignedChar>,
          int)>();

  int dc_parser_get_type(
    ffi.Pointer<dc_parser_t> parser,
  ) {
    return _dc_parser_get_type(
      parser,
    );
  }

  late final _dc_parser_get_typePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<dc_parser_t>)>>(
          'dc_parser_get_type');
  late final _dc_parser_get_type = _dc_parser_get_typePtr
      .asFunction<int Function(ffi.Pointer<dc_parser_t>)>();

  int dc_parser_set_clock(
    ffi.Pointer<dc_parser_t> parser,
    int devtime,
    int systime,
  ) {
    return _dc_parser_set_clock(
      parser,
      devtime,
      systime,
    );
  }

  late final _dc_parser_set_clockPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<dc_parser_t>, ffi.UnsignedInt,
              dc_ticks_t)>>('dc_parser_set_clock');
  late final _dc_parser_set_clock = _dc_parser_set_clockPtr
      .asFunction<int Function(ffi.Pointer<dc_parser_t>, int, int)>();

  int dc_parser_set_atmospheric(
    ffi.Pointer<dc_parser_t> parser,
    double atmospheric,
  ) {
    return _dc_parser_set_atmospheric(
      parser,
      atmospheric,
    );
  }

  late final _dc_parser_set_atmosphericPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<dc_parser_t>,
              ffi.Double)>>('dc_parser_set_atmospheric');
  late final _dc_parser_set_atmospheric = _dc_parser_set_atmosphericPtr
      .asFunction<int Function(ffi.Pointer<dc_parser_t>, double)>();

  int dc_parser_set_density(
    ffi.Pointer<dc_parser_t> parser,
    double density,
  ) {
    return _dc_parser_set_density(
      parser,
      density,
    );
  }

  late final _dc_parser_set_densityPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<dc_parser_t>, ffi.Double)>>('dc_parser_set_density');
  late final _dc_parser_set_density = _dc_parser_set_densityPtr
      .asFunction<int Function(ffi.Pointer<dc_parser_t>, double)>();

  int dc_parser_get_datetime(
    ffi.Pointer<dc_parser_t> parser,
    ffi.Pointer<dc_datetime_t> datetime,
  ) {
    return _dc_parser_get_datetime(
      parser,
      datetime,
    );
  }

  late final _dc_parser_get_datetimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<dc_parser_t>,
              ffi.Pointer<dc_datetime_t>)>>('dc_parser_get_datetime');
  late final _dc_parser_get_datetime = _dc_parser_get_datetimePtr.asFunction<
      int Function(ffi.Pointer<dc_parser_t>, ffi.Pointer<dc_datetime_t>)>();

  int dc_parser_get_field(
    ffi.Pointer<dc_parser_t> parser,
    int type,
    int flags,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _dc_parser_get_field(
      parser,
      type,
      flags,
      value,
    );
  }

  late final _dc_parser_get_fieldPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<dc_parser_t>, ffi.Int32,
              ffi.UnsignedInt, ffi.Pointer<ffi.Void>)>>('dc_parser_get_field');
  late final _dc_parser_get_field = _dc_parser_get_fieldPtr.asFunction<
      int Function(
          ffi.Pointer<dc_parser_t>, int, int, ffi.Pointer<ffi.Void>)>();

  int dc_parser_samples_foreach(
    ffi.Pointer<dc_parser_t> parser,
    dc_sample_callback_t callback,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _dc_parser_samples_foreach(
      parser,
      callback,
      userdata,
    );
  }

  late final _dc_parser_samples_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<dc_parser_t>, dc_sample_callback_t,
              ffi.Pointer<ffi.Void>)>>('dc_parser_samples_foreach');
  late final _dc_parser_samples_foreach =
      _dc_parser_samples_foreachPtr.asFunction<
          int Function(ffi.Pointer<dc_parser_t>, dc_sample_callback_t,
              ffi.Pointer<ffi.Void>)>();

  int dc_parser_destroy(
    ffi.Pointer<dc_parser_t> parser,
  ) {
    return _dc_parser_destroy(
      parser,
    );
  }

  late final _dc_parser_destroyPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<dc_parser_t>)>>(
          'dc_parser_destroy');
  late final _dc_parser_destroy = _dc_parser_destroyPtr
      .asFunction<int Function(ffi.Pointer<dc_parser_t>)>();

  /// Get the vendor id (VID) of the USB device.
  ///
  /// @param[in]  device  A valid USB device.
  int dc_usb_device_get_vid(
    ffi.Pointer<dc_usb_device_t> device,
  ) {
    return _dc_usb_device_get_vid(
      device,
    );
  }

  late final _dc_usb_device_get_vidPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<dc_usb_device_t>)>>('dc_usb_device_get_vid');
  late final _dc_usb_device_get_vid = _dc_usb_device_get_vidPtr
      .asFunction<int Function(ffi.Pointer<dc_usb_device_t>)>();

  /// Get the product id (PID) of the USB device.
  ///
  /// @param[in]  device  A valid USB device.
  int dc_usb_device_get_pid(
    ffi.Pointer<dc_usb_device_t> device,
  ) {
    return _dc_usb_device_get_pid(
      device,
    );
  }

  late final _dc_usb_device_get_pidPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<dc_usb_device_t>)>>('dc_usb_device_get_pid');
  late final _dc_usb_device_get_pid = _dc_usb_device_get_pidPtr
      .asFunction<int Function(ffi.Pointer<dc_usb_device_t>)>();

  /// Destroy the USB device and free all resources.
  ///
  /// @param[in]  device  A valid USB device.
  void dc_usb_device_free(
    ffi.Pointer<dc_usb_device_t> device,
  ) {
    return _dc_usb_device_free(
      device,
    );
  }

  late final _dc_usb_device_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<dc_usb_device_t>)>>(
      'dc_usb_device_free');
  late final _dc_usb_device_free = _dc_usb_device_freePtr
      .asFunction<void Function(ffi.Pointer<dc_usb_device_t>)>();

  /// Create an iterator to enumerate the USB devices.
  ///
  /// @param[out] iterator    A location to store the iterator.
  /// @param[in]  context     A valid context object.
  /// @param[in]  descriptor  A valid device descriptor or NULL.
  /// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
  /// on failure.
  int dc_usb_iterator_new(
    ffi.Pointer<ffi.Pointer<dc_iterator_t>> iterator,
    ffi.Pointer<dc_context_t> context,
    ffi.Pointer<dc_descriptor_t> descriptor,
  ) {
    return _dc_usb_iterator_new(
      iterator,
      context,
      descriptor,
    );
  }

  late final _dc_usb_iterator_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<dc_iterator_t>>,
              ffi.Pointer<dc_context_t>,
              ffi.Pointer<dc_descriptor_t>)>>('dc_usb_iterator_new');
  late final _dc_usb_iterator_new = _dc_usb_iterator_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<dc_iterator_t>>,
          ffi.Pointer<dc_context_t>, ffi.Pointer<dc_descriptor_t>)>();

  /// Open a USB connection.
  ///
  /// @param[out]  iostream A location to store the USB connection.
  /// @param[in]   context  A valid context object.
  /// @param[in]   device   A valid USB device.
  /// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
  /// on failure.
  int dc_usb_open(
    ffi.Pointer<ffi.Pointer<dc_iostream_t>> iostream,
    ffi.Pointer<dc_context_t> context,
    ffi.Pointer<dc_usb_device_t> device,
  ) {
    return _dc_usb_open(
      iostream,
      context,
      device,
    );
  }

  late final _dc_usb_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<dc_iostream_t>>,
              ffi.Pointer<dc_context_t>,
              ffi.Pointer<dc_usb_device_t>)>>('dc_usb_open');
  late final _dc_usb_open = _dc_usb_openPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<dc_iostream_t>>,
          ffi.Pointer<dc_context_t>, ffi.Pointer<dc_usb_device_t>)>();

  /// Get the vendor id (VID) of the USB HID device.
  ///
  /// @param[in]  device  A valid USB HID device.
  int dc_usbhid_device_get_vid(
    ffi.Pointer<dc_usbhid_device_t> device,
  ) {
    return _dc_usbhid_device_get_vid(
      device,
    );
  }

  late final _dc_usbhid_device_get_vidPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<dc_usbhid_device_t>)>>('dc_usbhid_device_get_vid');
  late final _dc_usbhid_device_get_vid = _dc_usbhid_device_get_vidPtr
      .asFunction<int Function(ffi.Pointer<dc_usbhid_device_t>)>();

  /// Get the product id (PID) of the USB HID device.
  ///
  /// @param[in]  device  A valid USB HID device.
  int dc_usbhid_device_get_pid(
    ffi.Pointer<dc_usbhid_device_t> device,
  ) {
    return _dc_usbhid_device_get_pid(
      device,
    );
  }

  late final _dc_usbhid_device_get_pidPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<dc_usbhid_device_t>)>>('dc_usbhid_device_get_pid');
  late final _dc_usbhid_device_get_pid = _dc_usbhid_device_get_pidPtr
      .asFunction<int Function(ffi.Pointer<dc_usbhid_device_t>)>();

  /// Destroy the USB HID device and free all resources.
  ///
  /// @param[in]  device  A valid USB HID device.
  void dc_usbhid_device_free(
    ffi.Pointer<dc_usbhid_device_t> device,
  ) {
    return _dc_usbhid_device_free(
      device,
    );
  }

  late final _dc_usbhid_device_freePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<dc_usbhid_device_t>)>>(
      'dc_usbhid_device_free');
  late final _dc_usbhid_device_free = _dc_usbhid_device_freePtr
      .asFunction<void Function(ffi.Pointer<dc_usbhid_device_t>)>();

  /// Create an iterator to enumerate the USB HID devices.
  ///
  /// @param[out] iterator    A location to store the iterator.
  /// @param[in]  context     A valid context object.
  /// @param[in]  descriptor  A valid device descriptor or NULL.
  /// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
  /// on failure.
  int dc_usbhid_iterator_new(
    ffi.Pointer<ffi.Pointer<dc_iterator_t>> iterator,
    ffi.Pointer<dc_context_t> context,
    ffi.Pointer<dc_descriptor_t> descriptor,
  ) {
    return _dc_usbhid_iterator_new(
      iterator,
      context,
      descriptor,
    );
  }

  late final _dc_usbhid_iterator_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<dc_iterator_t>>,
              ffi.Pointer<dc_context_t>,
              ffi.Pointer<dc_descriptor_t>)>>('dc_usbhid_iterator_new');
  late final _dc_usbhid_iterator_new = _dc_usbhid_iterator_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<dc_iterator_t>>,
          ffi.Pointer<dc_context_t>, ffi.Pointer<dc_descriptor_t>)>();

  /// Open a USB HID connection.
  ///
  /// @param[out]  iostream A location to store the USB HID connection.
  /// @param[in]   context  A valid context object.
  /// @param[in]   device   A valid USB HID device.
  /// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
  /// on failure.
  int dc_usbhid_open(
    ffi.Pointer<ffi.Pointer<dc_iostream_t>> iostream,
    ffi.Pointer<dc_context_t> context,
    ffi.Pointer<dc_usbhid_device_t> device,
  ) {
    return _dc_usbhid_open(
      iostream,
      context,
      device,
    );
  }

  late final _dc_usbhid_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<dc_iostream_t>>,
              ffi.Pointer<dc_context_t>,
              ffi.Pointer<dc_usbhid_device_t>)>>('dc_usbhid_open');
  late final _dc_usbhid_open = _dc_usbhid_openPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<dc_iostream_t>>,
          ffi.Pointer<dc_context_t>, ffi.Pointer<dc_usbhid_device_t>)>();

  /// Convert a bluetooth address to a string.
  ///
  /// The bluetooth address is formatted as XX:XX:XX:XX:XX:XX, where each
  /// XX is a hexadecimal number specifying an octet of the 48-bit address.
  /// The minimum size for the buffer is #DC_BLUETOOTH_SIZE bytes.
  ///
  /// @param[in]  address  A bluetooth address.
  /// @param[in]  str      The memory buffer to store the result.
  /// @param[in]  size     The size of the memory buffer.
  /// @returns The null-terminated string on success, or NULL on failure.
  ffi.Pointer<ffi.Char> dc_bluetooth_addr2str(
    int address,
    ffi.Pointer<ffi.Char> str,
    int size,
  ) {
    return _dc_bluetooth_addr2str(
      address,
      str,
      size,
    );
  }

  late final _dc_bluetooth_addr2strPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(dc_bluetooth_address_t,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('dc_bluetooth_addr2str');
  late final _dc_bluetooth_addr2str = _dc_bluetooth_addr2strPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  /// Convert a string to a bluetooth address.
  ///
  /// The string is expected to be in the format XX:XX:XX:XX:XX:XX, where
  /// each XX is a hexadecimal number specifying an octet of the 48-bit
  /// address.
  ///
  /// @param[in]  address  A null-terminated string.
  /// @returns The bluetooth address on success, or zero on failure.
  int dc_bluetooth_str2addr(
    ffi.Pointer<ffi.Char> address,
  ) {
    return _dc_bluetooth_str2addr(
      address,
    );
  }

  late final _dc_bluetooth_str2addrPtr = _lookup<
      ffi.NativeFunction<
          dc_bluetooth_address_t Function(
              ffi.Pointer<ffi.Char>)>>('dc_bluetooth_str2addr');
  late final _dc_bluetooth_str2addr = _dc_bluetooth_str2addrPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Get the address of the bluetooth device.
  ///
  /// @param[in]  device  A valid bluetooth device.
  int dc_bluetooth_device_get_address(
    ffi.Pointer<dc_bluetooth_device_t> device,
  ) {
    return _dc_bluetooth_device_get_address(
      device,
    );
  }

  late final _dc_bluetooth_device_get_addressPtr = _lookup<
          ffi.NativeFunction<
              dc_bluetooth_address_t Function(
                  ffi.Pointer<dc_bluetooth_device_t>)>>(
      'dc_bluetooth_device_get_address');
  late final _dc_bluetooth_device_get_address =
      _dc_bluetooth_device_get_addressPtr
          .asFunction<int Function(ffi.Pointer<dc_bluetooth_device_t>)>();

  /// Get the name of the bluetooth device.
  ///
  /// @param[in]  device  A valid bluetooth device.
  ffi.Pointer<ffi.Char> dc_bluetooth_device_get_name(
    ffi.Pointer<dc_bluetooth_device_t> device,
  ) {
    return _dc_bluetooth_device_get_name(
      device,
    );
  }

  late final _dc_bluetooth_device_get_namePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<dc_bluetooth_device_t>)>>(
      'dc_bluetooth_device_get_name');
  late final _dc_bluetooth_device_get_name =
      _dc_bluetooth_device_get_namePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<dc_bluetooth_device_t>)>();

  /// Destroy the bluetooth device and free all resources.
  ///
  /// @param[in]  device  A valid bluetooth device.
  void dc_bluetooth_device_free(
    ffi.Pointer<dc_bluetooth_device_t> device,
  ) {
    return _dc_bluetooth_device_free(
      device,
    );
  }

  late final _dc_bluetooth_device_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<dc_bluetooth_device_t>)>>('dc_bluetooth_device_free');
  late final _dc_bluetooth_device_free = _dc_bluetooth_device_freePtr
      .asFunction<void Function(ffi.Pointer<dc_bluetooth_device_t>)>();

  /// Create an iterator to enumerate the bluetooth devices.
  ///
  /// @param[out] iterator    A location to store the iterator.
  /// @param[in]  context     A valid context object.
  /// @param[in]  descriptor  A valid device descriptor or NULL.
  /// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
  /// on failure.
  int dc_bluetooth_iterator_new(
    ffi.Pointer<ffi.Pointer<dc_iterator_t>> iterator,
    ffi.Pointer<dc_context_t> context,
    ffi.Pointer<dc_descriptor_t> descriptor,
  ) {
    return _dc_bluetooth_iterator_new(
      iterator,
      context,
      descriptor,
    );
  }

  late final _dc_bluetooth_iterator_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<dc_iterator_t>>,
              ffi.Pointer<dc_context_t>,
              ffi.Pointer<dc_descriptor_t>)>>('dc_bluetooth_iterator_new');
  late final _dc_bluetooth_iterator_new =
      _dc_bluetooth_iterator_newPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<dc_iterator_t>>,
              ffi.Pointer<dc_context_t>, ffi.Pointer<dc_descriptor_t>)>();

  /// Open an bluetooth connection.
  ///
  /// @param[out]  iostream   A location to store the bluetooth connection.
  /// @param[in]   context    A valid context object.
  /// @param[in]   address    The bluetooth device address.
  /// @param[in]   port       The bluetooth port number.
  /// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
  /// on failure.
  int dc_bluetooth_open(
    ffi.Pointer<ffi.Pointer<dc_iostream_t>> iostream,
    ffi.Pointer<dc_context_t> context,
    int address,
    int port,
  ) {
    return _dc_bluetooth_open(
      iostream,
      context,
      address,
      port,
    );
  }

  late final _dc_bluetooth_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<dc_iostream_t>>,
              ffi.Pointer<dc_context_t>,
              dc_bluetooth_address_t,
              ffi.UnsignedInt)>>('dc_bluetooth_open');
  late final _dc_bluetooth_open = _dc_bluetooth_openPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<dc_iostream_t>>,
          ffi.Pointer<dc_context_t>, int, int)>();

  /// Create a custom I/O stream.
  ///
  /// @param[out]  iostream   A location to store the custom I/O stream.
  /// @param[in]   context    A valid context object.
  /// @param[in]   callbacks  The callback functions to call.
  /// @param[in]   userdata   User data to pass to the callback functions.
  /// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
  /// on failure.
  int dc_custom_open(
    ffi.Pointer<ffi.Pointer<dc_iostream_t>> iostream,
    ffi.Pointer<dc_context_t> context,
    int transport,
    ffi.Pointer<dc_custom_cbs_t> callbacks,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _dc_custom_open(
      iostream,
      context,
      transport,
      callbacks,
      userdata,
    );
  }

  late final _dc_custom_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<dc_iostream_t>>,
              ffi.Pointer<dc_context_t>,
              ffi.Int32,
              ffi.Pointer<dc_custom_cbs_t>,
              ffi.Pointer<ffi.Void>)>>('dc_custom_open');
  late final _dc_custom_open = _dc_custom_openPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<dc_iostream_t>>,
          ffi.Pointer<dc_context_t>,
          int,
          ffi.Pointer<dc_custom_cbs_t>,
          ffi.Pointer<ffi.Void>)>();
}

abstract class dc_status_t {
  static const int DC_STATUS_SUCCESS = 0;
  static const int DC_STATUS_DONE = 1;
  static const int DC_STATUS_UNSUPPORTED = -1;
  static const int DC_STATUS_INVALIDARGS = -2;
  static const int DC_STATUS_NOMEMORY = -3;
  static const int DC_STATUS_NODEVICE = -4;
  static const int DC_STATUS_NOACCESS = -5;
  static const int DC_STATUS_IO = -6;
  static const int DC_STATUS_TIMEOUT = -7;
  static const int DC_STATUS_PROTOCOL = -8;
  static const int DC_STATUS_DATAFORMAT = -9;
  static const int DC_STATUS_CANCELLED = -10;
}

abstract class dc_transport_t {
  static const int DC_TRANSPORT_NONE = 0;
  static const int DC_TRANSPORT_SERIAL = 1;
  static const int DC_TRANSPORT_USB = 2;
  static const int DC_TRANSPORT_USBHID = 4;
  static const int DC_TRANSPORT_IRDA = 8;
  static const int DC_TRANSPORT_BLUETOOTH = 16;
  static const int DC_TRANSPORT_BLE = 32;
}

abstract class dc_family_t {
  static const int DC_FAMILY_NULL = 0;

  /// Suunto
  static const int DC_FAMILY_SUUNTO_SOLUTION = 65536;
  static const int DC_FAMILY_SUUNTO_EON = 65537;
  static const int DC_FAMILY_SUUNTO_VYPER = 65538;
  static const int DC_FAMILY_SUUNTO_VYPER2 = 65539;
  static const int DC_FAMILY_SUUNTO_D9 = 65540;
  static const int DC_FAMILY_SUUNTO_EONSTEEL = 65541;

  /// Reefnet
  static const int DC_FAMILY_REEFNET_SENSUS = 131072;
  static const int DC_FAMILY_REEFNET_SENSUSPRO = 131073;
  static const int DC_FAMILY_REEFNET_SENSUSULTRA = 131074;

  /// Uwatec
  static const int DC_FAMILY_UWATEC_ALADIN = 196608;
  static const int DC_FAMILY_UWATEC_MEMOMOUSE = 196609;
  static const int DC_FAMILY_UWATEC_SMART = 196610;

  /// Deprecated: integrated into the Uwatec Smart family.
  static const int DC_FAMILY_UWATEC_MERIDIAN = 196611;

  /// Deprecated: integrated into the Uwatec Smart family.
  static const int DC_FAMILY_UWATEC_G2 = 196612;

  /// Oceanic
  static const int DC_FAMILY_OCEANIC_VTPRO = 262144;
  static const int DC_FAMILY_OCEANIC_VEO250 = 262145;
  static const int DC_FAMILY_OCEANIC_ATOM2 = 262146;

  /// Mares
  static const int DC_FAMILY_MARES_NEMO = 327680;
  static const int DC_FAMILY_MARES_PUCK = 327681;
  static const int DC_FAMILY_MARES_DARWIN = 327682;
  static const int DC_FAMILY_MARES_ICONHD = 327683;

  /// Heinrichs Weikamp
  static const int DC_FAMILY_HW_OSTC = 393216;
  static const int DC_FAMILY_HW_FROG = 393217;
  static const int DC_FAMILY_HW_OSTC3 = 393218;

  /// Cressi
  static const int DC_FAMILY_CRESSI_EDY = 458752;
  static const int DC_FAMILY_CRESSI_LEONARDO = 458753;
  static const int DC_FAMILY_CRESSI_GOA = 458754;

  /// Zeagle
  static const int DC_FAMILY_ZEAGLE_N2ITION3 = 524288;

  /// Atomic Aquatics
  static const int DC_FAMILY_ATOMICS_COBALT = 589824;

  /// Shearwater
  static const int DC_FAMILY_SHEARWATER_PREDATOR = 655360;
  static const int DC_FAMILY_SHEARWATER_PETREL = 655361;

  /// Dive Rite
  static const int DC_FAMILY_DIVERITE_NITEKQ = 720896;

  /// Citizen
  static const int DC_FAMILY_CITIZEN_AQUALAND = 786432;

  /// DiveSystem
  static const int DC_FAMILY_DIVESYSTEM_IDIVE = 851968;

  /// Cochran
  static const int DC_FAMILY_COCHRAN_COMMANDER = 917504;

  /// Tecdiving
  static const int DC_FAMILY_TECDIVING_DIVECOMPUTEREU = 983040;

  /// McLean
  static const int DC_FAMILY_MCLEAN_EXTREME = 1048576;

  /// Liquivision
  static const int DC_FAMILY_LIQUIVISION_LYNX = 1114112;

  /// Sporasub
  static const int DC_FAMILY_SPORASUB_SP2 = 1179648;

  /// Deep Six
  static const int DC_FAMILY_DEEPSIX_EXCURSION = 1245184;

  /// Seac Screen
  static const int DC_FAMILY_SEAC_SCREEN = 1310720;

  /// Deepblu Cosmiq
  static const int DC_FAMILY_DEEPBLU_COSMIQ = 1376256;

  /// Oceans S1
  static const int DC_FAMILY_OCEANS_S1 = 1441792;

  /// Divesoft Freedom
  static const int DC_FAMILY_DIVESOFT_FREEDOM = 1507328;
}

final class dc_context_t extends ffi.Opaque {}

abstract final class dc_loglevel_t {
  static const int DC_LOGLEVEL_NONE = 0;
  static const int DC_LOGLEVEL_ERROR = 1;
  static const int DC_LOGLEVEL_WARNING = 2;
  static const int DC_LOGLEVEL_INFO = 3;
  static const int DC_LOGLEVEL_DEBUG = 4;
  static const int DC_LOGLEVEL_ALL = 5;
}

typedef dc_logfunc_t = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(
            ffi.Pointer<dc_context_t> context,
            ffi.Int32 loglevel,
            ffi.Pointer<ffi.Char> file,
            ffi.UnsignedInt line,
            ffi.Pointer<ffi.Char> function,
            ffi.Pointer<ffi.Char> message,
            ffi.Pointer<ffi.Void> userdata)>>;

final class dc_iterator_t extends ffi.Opaque {}

final class dc_descriptor_t extends ffi.Opaque {}

/// mbstate_t is an opaque object to keep conversion state, during multibyte
/// stream conversions.  The content must not be referenced by user programs.
final class __mbstate_t extends ffi.Union {
  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> __mbstate8;

  /// for alignment
  @ffi.LongLong()
  external int _mbstateL;
}

final class __darwin_pthread_handler_rec extends ffi.Struct {
  /// Routine to call
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      __routine;

  /// Argument to pass
  external ffi.Pointer<ffi.Void> __arg;

  external ffi.Pointer<__darwin_pthread_handler_rec> __next;
}

final class _opaque_pthread_attr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_cond_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([40])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_condattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_mutex_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_mutexattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_once_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_rwlock_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([192])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_rwlockattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  external ffi.Pointer<__darwin_pthread_handler_rec> __cleanup_stack;

  @ffi.Array.multi([8176])
  external ffi.Array<ffi.Char> __opaque;
}

final class dc_iostream_t extends ffi.Opaque {}

/// The parity checking scheme.
abstract class dc_parity_t {
  /// < No parity
  static const int DC_PARITY_NONE = 0;

  /// < Odd parity
  static const int DC_PARITY_ODD = 1;

  /// < Even parity
  static const int DC_PARITY_EVEN = 2;

  /// < Mark parity (always 1)
  static const int DC_PARITY_MARK = 3;

  /// < Space parity (alwasy 0)
  static const int DC_PARITY_SPACE = 4;
}

/// The number of stop bits.
abstract class dc_stopbits_t {
  /// < 1 stop bit
  static const int DC_STOPBITS_ONE = 0;

  /// < 1.5 stop bits
  static const int DC_STOPBITS_ONEPOINTFIVE = 1;

  /// < 2 stop bits
  static const int DC_STOPBITS_TWO = 2;
}

/// The flow control.
abstract class dc_flowcontrol_t {
  /// < No flow control
  static const int DC_FLOWCONTROL_NONE = 0;

  /// < Hardware (RTS/CTS) flow control
  static const int DC_FLOWCONTROL_HARDWARE = 1;

  /// < Software (XON/XOFF) flow control
  static const int DC_FLOWCONTROL_SOFTWARE = 2;
}

/// The direction of the data transmission.
abstract class dc_direction_t {
  /// < Input direction
  static const int DC_DIRECTION_INPUT = 1;

  /// < Output direction
  static const int DC_DIRECTION_OUTPUT = 2;

  /// < All directions
  static const int DC_DIRECTION_ALL = 3;
}

/// The line signals.
abstract class dc_line_t {
  /// < Data carrier detect
  static const int DC_LINE_DCD = 1;

  /// < Clear to send
  static const int DC_LINE_CTS = 2;

  /// < Data set ready
  static const int DC_LINE_DSR = 4;

  /// < Ring indicator
  static const int DC_LINE_RNG = 8;
}

final class dc_buffer_t extends ffi.Opaque {}

final class dc_datetime_t extends ffi.Struct {
  @ffi.Int()
  external int year;

  @ffi.Int()
  external int month;

  @ffi.Int()
  external int day;

  @ffi.Int()
  external int hour;

  @ffi.Int()
  external int minute;

  @ffi.Int()
  external int second;

  @ffi.Int()
  external int timezone;
}

typedef dc_ticks_t = ffi.LongLong;

abstract class dc_event_type_t {
  static const int DC_EVENT_WAITING = 1;
  static const int DC_EVENT_PROGRESS = 2;
  static const int DC_EVENT_DEVINFO = 4;
  static const int DC_EVENT_CLOCK = 8;
  static const int DC_EVENT_VENDOR = 16;
}

final class dc_device_t extends ffi.Opaque {}

final class dc_event_progress_t extends ffi.Struct {
  @ffi.UnsignedInt()
  external int current;

  @ffi.UnsignedInt()
  external int maximum;
}

final class dc_event_devinfo_t extends ffi.Struct {
  @ffi.UnsignedInt()
  external int model;

  @ffi.UnsignedInt()
  external int firmware;

  @ffi.UnsignedInt()
  external int serial;
}

final class dc_event_clock_t extends ffi.Struct {
  @ffi.UnsignedInt()
  external int devtime;

  @dc_ticks_t()
  external int systime;
}

final class dc_event_vendor_t extends ffi.Struct {
  external ffi.Pointer<ffi.UnsignedChar> data;

  @ffi.UnsignedInt()
  external int size;
}

typedef dc_cancel_callback_t = ffi.Pointer<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void> userdata)>>;
typedef dc_event_callback_t = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<dc_device_t> device, ffi.Int32 event,
            ffi.Pointer<ffi.Void> data, ffi.Pointer<ffi.Void> userdata)>>;
typedef dc_dive_callback_t = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(
            ffi.Pointer<ffi.UnsignedChar> data,
            ffi.UnsignedInt size,
            ffi.Pointer<ffi.UnsignedChar> fingerprint,
            ffi.UnsignedInt fsize,
            ffi.Pointer<ffi.Void> userdata)>>;

final class dc_serial_device_t extends ffi.Opaque {}

abstract class dc_sample_type_t {
  static const int DC_SAMPLE_TIME = 0;
  static const int DC_SAMPLE_DEPTH = 1;
  static const int DC_SAMPLE_PRESSURE = 2;
  static const int DC_SAMPLE_TEMPERATURE = 3;
  static const int DC_SAMPLE_EVENT = 4;
  static const int DC_SAMPLE_RBT = 5;
  static const int DC_SAMPLE_HEARTBEAT = 6;
  static const int DC_SAMPLE_BEARING = 7;
  static const int DC_SAMPLE_VENDOR = 8;
  static const int DC_SAMPLE_SETPOINT = 9;
  static const int DC_SAMPLE_PPO2 = 10;
  static const int DC_SAMPLE_CNS = 11;
  static const int DC_SAMPLE_DECO = 12;
  static const int DC_SAMPLE_GASMIX = 13;
}

abstract class dc_field_type_t {
  static const int DC_FIELD_DIVETIME = 0;
  static const int DC_FIELD_MAXDEPTH = 1;
  static const int DC_FIELD_AVGDEPTH = 2;
  static const int DC_FIELD_GASMIX_COUNT = 3;
  static const int DC_FIELD_GASMIX = 4;
  static const int DC_FIELD_SALINITY = 5;
  static const int DC_FIELD_ATMOSPHERIC = 6;
  static const int DC_FIELD_TEMPERATURE_SURFACE = 7;
  static const int DC_FIELD_TEMPERATURE_MINIMUM = 8;
  static const int DC_FIELD_TEMPERATURE_MAXIMUM = 9;
  static const int DC_FIELD_TANK_COUNT = 10;
  static const int DC_FIELD_TANK = 11;
  static const int DC_FIELD_DIVEMODE = 12;
  static const int DC_FIELD_DECOMODEL = 13;
}

abstract class parser_sample_event_t {
  static const int SAMPLE_EVENT_NONE = 0;
  static const int SAMPLE_EVENT_DECOSTOP = 1;
  static const int SAMPLE_EVENT_RBT = 2;
  static const int SAMPLE_EVENT_ASCENT = 3;
  static const int SAMPLE_EVENT_CEILING = 4;
  static const int SAMPLE_EVENT_WORKLOAD = 5;
  static const int SAMPLE_EVENT_TRANSMITTER = 6;
  static const int SAMPLE_EVENT_VIOLATION = 7;
  static const int SAMPLE_EVENT_BOOKMARK = 8;
  static const int SAMPLE_EVENT_SURFACE = 9;
  static const int SAMPLE_EVENT_SAFETYSTOP = 10;

  /// Deprecated: replaced by DC_SAMPLE_GASMIX.
  static const int SAMPLE_EVENT_GASCHANGE = 11;
  static const int SAMPLE_EVENT_SAFETYSTOP_VOLUNTARY = 12;
  static const int SAMPLE_EVENT_SAFETYSTOP_MANDATORY = 13;
  static const int SAMPLE_EVENT_DEEPSTOP = 14;
  static const int SAMPLE_EVENT_CEILING_SAFETYSTOP = 15;
  static const int SAMPLE_EVENT_FLOOR = 16;
  static const int SAMPLE_EVENT_DIVETIME = 17;
  static const int SAMPLE_EVENT_MAXDEPTH = 18;
  static const int SAMPLE_EVENT_OLF = 19;
  static const int SAMPLE_EVENT_PO2 = 20;
  static const int SAMPLE_EVENT_AIRTIME = 21;
  static const int SAMPLE_EVENT_RGBM = 22;
  static const int SAMPLE_EVENT_HEADING = 23;
  static const int SAMPLE_EVENT_TISSUELEVEL = 24;

  /// Deprecated: replaced by DC_SAMPLE_GASMIX.
  static const int SAMPLE_EVENT_GASCHANGE2 = 25;
}

abstract class parser_sample_flags_t {
  static const int SAMPLE_FLAGS_NONE = 0;
  static const int SAMPLE_FLAGS_BEGIN = 1;
  static const int SAMPLE_FLAGS_END = 2;
}

abstract class parser_sample_vendor_t {
  static const int SAMPLE_VENDOR_NONE = 0;
  static const int SAMPLE_VENDOR_UWATEC_ALADIN = 1;
  static const int SAMPLE_VENDOR_UWATEC_SMART = 2;
  static const int SAMPLE_VENDOR_OCEANIC_VTPRO = 3;
  static const int SAMPLE_VENDOR_OCEANIC_VEO250 = 4;
  static const int SAMPLE_VENDOR_OCEANIC_ATOM2 = 5;
}

abstract class dc_water_t {
  static const int DC_WATER_FRESH = 0;
  static const int DC_WATER_SALT = 1;
}

abstract class dc_divemode_t {
  static const int DC_DIVEMODE_FREEDIVE = 0;
  static const int DC_DIVEMODE_GAUGE = 1;

  /// Open circuit
  static const int DC_DIVEMODE_OC = 2;

  /// Closed circuit rebreather
  static const int DC_DIVEMODE_CCR = 3;

  /// Semi-closed circuit rebreather
  static const int DC_DIVEMODE_SCR = 4;
}

abstract class dc_deco_type_t {
  static const int DC_DECO_NDL = 0;
  static const int DC_DECO_SAFETYSTOP = 1;
  static const int DC_DECO_DECOSTOP = 2;
  static const int DC_DECO_DEEPSTOP = 3;
}

final class dc_salinity_t extends ffi.Struct {
  @ffi.Int32()
  external int type;

  @ffi.Double()
  external double density;
}

abstract class dc_usage_t {
  static const int DC_USAGE_NONE = 0;
  static const int DC_USAGE_OXYGEN = 1;
  static const int DC_USAGE_DILUENT = 2;
  static const int DC_USAGE_SIDEMOUNT = 3;
}

final class dc_gasmix_t extends ffi.Struct {
  @ffi.Double()
  external double helium;

  @ffi.Double()
  external double oxygen;

  @ffi.Double()
  external double nitrogen;

  @ffi.Int32()
  external int usage;
}

abstract class dc_tankvolume_t {
  static const int DC_TANKVOLUME_NONE = 0;
  static const int DC_TANKVOLUME_METRIC = 1;
  static const int DC_TANKVOLUME_IMPERIAL = 2;
}

/// Tank volume
///
/// There are two different ways to specify the volume of a tank. In the
/// metric system, the tank volume is specified as the water capacity,
/// while in the imperial system the tank volume is specified as the air
/// capacity at the surface (1 ATM) when the tank is filled at its
/// working pressure. Libdivecomputer will always convert the tank volume
/// to the metric representation, and indicate the original tank type:
///
/// DC_TANKVOLUME_NONE: Tank volume is not available. Both the volume and
/// workpressure will be zero.
///
/// DC_TANKVOLUME_METRIC: A metric tank. The workpressure is optional and
/// may be zero.
///
/// DC_TANKVOLUME_IMPERIAL: An imperial tank. Both the volume and
/// workpressure are mandatory and always non-zero. The volume has been
/// converted from air capacity to water capacity. To calculate the
/// original air capacity again, multiply with the workpressure and
/// divide by 1 ATM (Vair = Vwater * Pwork / Patm).
final class dc_tank_t extends ffi.Struct {
  /// Gas mix index, or DC_GASMIX_UNKNOWN
  @ffi.UnsignedInt()
  external int gasmix;

  /// Tank type
  @ffi.Int32()
  external int type;

  /// Volume (liter)
  @ffi.Double()
  external double volume;

  /// Work pressure (bar)
  @ffi.Double()
  external double workpressure;

  /// Begin pressure (bar)
  @ffi.Double()
  external double beginpressure;

  /// End pressure (bar)
  @ffi.Double()
  external double endpressure;

  @ffi.Int32()
  external int usage;
}

abstract class dc_decomodel_type_t {
  static const int DC_DECOMODEL_NONE = 0;
  static const int DC_DECOMODEL_BUHLMANN = 1;
  static const int DC_DECOMODEL_VPM = 2;
  static const int DC_DECOMODEL_RGBM = 3;
  static const int DC_DECOMODEL_DCIEM = 4;
}

/// Decompression model
///
/// The type field contains the decompression algorithm.
///
/// The (optional) conservatism field contains the personal adjustment
/// setting of the algorithm. The exact interpretation depends on the
/// dive computer, but the default value (zero) will typically correspond
/// to the neutral setting, while a positive value is more conservative
/// and a negative value more aggressive.
///
/// The (optional) params field contains the parameters of the algorithm:
///
/// DC_DECOMODEL_BUHLMANN: The Gradient Factor (GF) parameters low and
/// high. For a pure Buhlmann algorithm (e.g. without GF enabled), both
/// values are 100. If GF are enabled, but the actual parameter values
/// are not available from the dive computer, both values are zero.
final class dc_decomodel_t extends ffi.Struct {
  @ffi.Int32()
  external int type;

  @ffi.Int()
  external int conservatism;

  external UnnamedUnion1 params;
}

final class UnnamedUnion1 extends ffi.Union {
  external UnnamedStruct1 gf;
}

final class UnnamedStruct1 extends ffi.Struct {
  @ffi.UnsignedInt()
  external int high;

  @ffi.UnsignedInt()
  external int low;
}

final class dc_sample_value_t extends ffi.Union {
  /// Milliseconds
  @ffi.UnsignedInt()
  external int time;

  @ffi.Double()
  external double depth;

  external UnnamedStruct2 pressure;

  @ffi.Double()
  external double temperature;

  external UnnamedStruct3 event;

  @ffi.UnsignedInt()
  external int rbt;

  @ffi.UnsignedInt()
  external int heartbeat;

  @ffi.UnsignedInt()
  external int bearing;

  external UnnamedStruct4 vendor;

  @ffi.Double()
  external double setpoint;

  external UnnamedStruct5 ppo2;

  @ffi.Double()
  external double cns;

  external UnnamedStruct6 deco;

  /// Gas mix index
  @ffi.UnsignedInt()
  external int gasmix;
}

final class UnnamedStruct2 extends ffi.Struct {
  @ffi.UnsignedInt()
  external int tank;

  @ffi.Double()
  external double value;
}

final class UnnamedStruct3 extends ffi.Struct {
  @ffi.UnsignedInt()
  external int type;

  @ffi.UnsignedInt()
  external int time;

  @ffi.UnsignedInt()
  external int flags;

  @ffi.UnsignedInt()
  external int value;
}

final class UnnamedStruct4 extends ffi.Struct {
  @ffi.UnsignedInt()
  external int type;

  @ffi.UnsignedInt()
  external int size;

  external ffi.Pointer<ffi.Void> data;
}

final class UnnamedStruct5 extends ffi.Struct {
  @ffi.UnsignedInt()
  external int sensor;

  @ffi.Double()
  external double value;
}

final class UnnamedStruct6 extends ffi.Struct {
  @ffi.UnsignedInt()
  external int type;

  @ffi.UnsignedInt()
  external int time;

  @ffi.Double()
  external double depth;

  @ffi.UnsignedInt()
  external int tts;
}

final class dc_parser_t extends ffi.Opaque {}

typedef dc_sample_callback_t = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Int32 type, ffi.Pointer<dc_sample_value_t> value,
            ffi.Pointer<ffi.Void> userdata)>>;

/// USB control transfer.
final class dc_usb_control_t extends ffi.Struct {
  @ffi.UnsignedChar()
  external int bmRequestType;

  @ffi.UnsignedChar()
  external int bRequest;

  @ffi.UnsignedShort()
  external int wValue;

  @ffi.UnsignedShort()
  external int wIndex;

  @ffi.UnsignedShort()
  external int wLength;
}

/// Endpoint direction bits of the USB control transfer.
abstract class dc_usb_endpoint_t {
  static const int DC_USB_ENDPOINT_OUT = 0;
  static const int DC_USB_ENDPOINT_IN = 128;
}

/// Request type bits of the USB control transfer.
abstract class dc_usb_request_t {
  static const int DC_USB_REQUEST_STANDARD = 0;
  static const int DC_USB_REQUEST_CLASS = 32;
  static const int DC_USB_REQUEST_VENDOR = 64;
  static const int DC_USB_REQUEST_RESERVED = 96;
}

/// Recipient bits of the USB control transfer.
abstract class dc_usb_recipient_t {
  static const int DC_USB_RECIPIENT_DEVICE = 0;
  static const int DC_USB_RECIPIENT_INTERFACE = 1;
  static const int DC_USB_RECIPIENT_ENDPOINT = 2;
  static const int DC_USB_RECIPIENT_OTHER = 3;
}

/// USB device descriptor.
final class dc_usb_desc_t extends ffi.Struct {
  @ffi.UnsignedShort()
  external int vid;

  @ffi.UnsignedShort()
  external int pid;
}

final class dc_usb_device_t extends ffi.Opaque {}

/// USB HID device descriptor.
final class dc_usbhid_desc_t extends ffi.Struct {
  @ffi.UnsignedShort()
  external int vid;

  @ffi.UnsignedShort()
  external int pid;
}

final class dc_usbhid_device_t extends ffi.Opaque {}

typedef dc_bluetooth_address_t = ffi.UnsignedLongLong;

final class dc_bluetooth_device_t extends ffi.Opaque {}

final class dc_custom_cbs_t extends ffi.Struct {
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Void> userdata, ffi.Int timeout)>> set_timeout;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<ffi.Void> userdata, ffi.UnsignedInt value)>>
      set_break;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Void> userdata, ffi.UnsignedInt value)>> set_dtr;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Void> userdata, ffi.UnsignedInt value)>> set_rts;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Void> userdata,
              ffi.Pointer<ffi.UnsignedInt> value)>> get_lines;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<ffi.Void> userdata, ffi.Pointer<ffi.Size> value)>>
      get_available;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Void> userdata,
              ffi.UnsignedInt baudrate,
              ffi.UnsignedInt databits,
              ffi.Int32 parity,
              ffi.Int32 stopbits,
              ffi.Int32 flowcontrol)>> configure;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Void> userdata, ffi.Int timeout)>> poll;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Void> userdata,
              ffi.Pointer<ffi.Void> data,
              ffi.Size size,
              ffi.Pointer<ffi.Size> actual)>> read;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Void> userdata,
              ffi.Pointer<ffi.Void> data,
              ffi.Size size,
              ffi.Pointer<ffi.Size> actual)>> write;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Void> userdata,
              ffi.UnsignedInt request,
              ffi.Pointer<ffi.Void> data,
              ffi.Size size)>> ioctl;

  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void> userdata)>>
      flush;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Void> userdata, ffi.Int32 direction)>> purge;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Void> userdata,
              ffi.UnsignedInt milliseconds)>> sleep;

  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void> userdata)>>
      close;
}

const int __DARWIN_ONLY_64_BIT_INO_T = 1;

const int __DARWIN_ONLY_UNIX_CONFORMANCE = 1;

const int __DARWIN_ONLY_VERS_1050 = 1;

const int __DARWIN_UNIX03 = 1;

const int __DARWIN_64_BIT_INO_T = 1;

const int __DARWIN_VERS_1050 = 1;

const int __DARWIN_NON_CANCELABLE = 0;

const String __DARWIN_SUF_EXTSN = '\$DARWIN_EXTSN';

const int __DARWIN_C_ANSI = 4096;

const int __DARWIN_C_FULL = 900000;

const int __DARWIN_C_LEVEL = 900000;

const int __STDC_WANT_LIB_EXT1__ = 1;

const int __DARWIN_NO_LONG_LONG = 0;

const int _DARWIN_FEATURE_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_VERS_1050 = 1;

const int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = 1;

const int _DARWIN_FEATURE_UNIX_CONFORMANCE = 3;

const int __has_ptrcheck = 0;

const int __DARWIN_NULL = 0;

const int __PTHREAD_SIZE__ = 8176;

const int __PTHREAD_ATTR_SIZE__ = 56;

const int __PTHREAD_MUTEXATTR_SIZE__ = 8;

const int __PTHREAD_MUTEX_SIZE__ = 56;

const int __PTHREAD_CONDATTR_SIZE__ = 8;

const int __PTHREAD_COND_SIZE__ = 40;

const int __PTHREAD_ONCE_SIZE__ = 8;

const int __PTHREAD_RWLOCK_SIZE__ = 192;

const int __PTHREAD_RWLOCKATTR_SIZE__ = 16;

const int __DARWIN_WCHAR_MAX = 2147483647;

const int __DARWIN_WCHAR_MIN = -2147483648;

const int __DARWIN_WEOF = -1;

const int _FORTIFY_SOURCE = 2;

const int NULL = 0;

const int USER_ADDR_NULL = 0;

const int __DARWIN_CLK_TCK = 100;

const int MB_LEN_MAX = 6;

const int CLK_TCK = 100;

const int CHAR_BIT = 8;

const int SCHAR_MAX = 127;

const int SCHAR_MIN = -128;

const int UCHAR_MAX = 255;

const int CHAR_MAX = 127;

const int CHAR_MIN = -128;

const int USHRT_MAX = 65535;

const int SHRT_MAX = 32767;

const int SHRT_MIN = -32768;

const int UINT_MAX = 4294967295;

const int INT_MAX = 2147483647;

const int INT_MIN = -2147483648;

const int ULONG_MAX = -1;

const int LONG_MAX = 9223372036854775807;

const int LONG_MIN = -9223372036854775808;

const int ULLONG_MAX = -1;

const int LLONG_MAX = 9223372036854775807;

const int LLONG_MIN = -9223372036854775808;

const int LONG_BIT = 64;

const int SSIZE_MAX = 9223372036854775807;

const int WORD_BIT = 32;

const int SIZE_T_MAX = -1;

const int UQUAD_MAX = -1;

const int QUAD_MAX = 9223372036854775807;

const int QUAD_MIN = -9223372036854775808;

const int ARG_MAX = 1048576;

const int CHILD_MAX = 266;

const int GID_MAX = 2147483647;

const int LINK_MAX = 32767;

const int MAX_CANON = 1024;

const int MAX_INPUT = 1024;

const int NAME_MAX = 255;

const int NGROUPS_MAX = 16;

const int UID_MAX = 2147483647;

const int OPEN_MAX = 10240;

const int PATH_MAX = 1024;

const int PIPE_BUF = 512;

const int BC_BASE_MAX = 99;

const int BC_DIM_MAX = 2048;

const int BC_SCALE_MAX = 99;

const int BC_STRING_MAX = 1000;

const int CHARCLASS_NAME_MAX = 14;

const int COLL_WEIGHTS_MAX = 2;

const int EQUIV_CLASS_MAX = 2;

const int EXPR_NEST_MAX = 32;

const int LINE_MAX = 2048;

const int RE_DUP_MAX = 255;

const int NZERO = 20;

const int _POSIX_ARG_MAX = 4096;

const int _POSIX_CHILD_MAX = 25;

const int _POSIX_LINK_MAX = 8;

const int _POSIX_MAX_CANON = 255;

const int _POSIX_MAX_INPUT = 255;

const int _POSIX_NAME_MAX = 14;

const int _POSIX_NGROUPS_MAX = 8;

const int _POSIX_OPEN_MAX = 20;

const int _POSIX_PATH_MAX = 256;

const int _POSIX_PIPE_BUF = 512;

const int _POSIX_SSIZE_MAX = 32767;

const int _POSIX_STREAM_MAX = 8;

const int _POSIX_TZNAME_MAX = 6;

const int _POSIX2_BC_BASE_MAX = 99;

const int _POSIX2_BC_DIM_MAX = 2048;

const int _POSIX2_BC_SCALE_MAX = 99;

const int _POSIX2_BC_STRING_MAX = 1000;

const int _POSIX2_EQUIV_CLASS_MAX = 2;

const int _POSIX2_EXPR_NEST_MAX = 32;

const int _POSIX2_LINE_MAX = 2048;

const int _POSIX2_RE_DUP_MAX = 255;

const int _POSIX_AIO_LISTIO_MAX = 2;

const int _POSIX_AIO_MAX = 1;

const int _POSIX_DELAYTIMER_MAX = 32;

const int _POSIX_MQ_OPEN_MAX = 8;

const int _POSIX_MQ_PRIO_MAX = 32;

const int _POSIX_RTSIG_MAX = 8;

const int _POSIX_SEM_NSEMS_MAX = 256;

const int _POSIX_SEM_VALUE_MAX = 32767;

const int _POSIX_SIGQUEUE_MAX = 32;

const int _POSIX_TIMER_MAX = 32;

const int _POSIX_CLOCKRES_MIN = 20000000;

const int _POSIX_THREAD_DESTRUCTOR_ITERATIONS = 4;

const int _POSIX_THREAD_KEYS_MAX = 128;

const int _POSIX_THREAD_THREADS_MAX = 64;

const int PTHREAD_DESTRUCTOR_ITERATIONS = 4;

const int PTHREAD_KEYS_MAX = 512;

const int PTHREAD_STACK_MIN = 16384;

const int _POSIX_HOST_NAME_MAX = 255;

const int _POSIX_LOGIN_NAME_MAX = 9;

const int _POSIX_SS_REPL_MAX = 4;

const int _POSIX_SYMLINK_MAX = 255;

const int _POSIX_SYMLOOP_MAX = 8;

const int _POSIX_TRACE_EVENT_NAME_MAX = 30;

const int _POSIX_TRACE_NAME_MAX = 8;

const int _POSIX_TRACE_SYS_MAX = 8;

const int _POSIX_TRACE_USER_EVENT_MAX = 32;

const int _POSIX_TTY_NAME_MAX = 9;

const int _POSIX2_CHARCLASS_NAME_MAX = 14;

const int _POSIX2_COLL_WEIGHTS_MAX = 2;

const int _POSIX_RE_DUP_MAX = 255;

const int OFF_MIN = -9223372036854775808;

const int OFF_MAX = 9223372036854775807;

const int PASS_MAX = 128;

const int NL_ARGMAX = 9;

const int NL_LANGMAX = 14;

const int NL_MSGMAX = 32767;

const int NL_NMAX = 1;

const int NL_SETMAX = 255;

const int NL_TEXTMAX = 2048;

const int _XOPEN_IOV_MAX = 16;

const int IOV_MAX = 1024;

const int _XOPEN_NAME_MAX = 255;

const int _XOPEN_PATH_MAX = 1024;

const int DC_TIMEZONE_NONE = -2147483648;

const int DC_IOCTL_DIR_NONE = 0;

const int DC_IOCTL_DIR_READ = 1;

const int DC_IOCTL_DIR_WRITE = 2;

const int DC_IOCTL_SIZE_VARIABLE = 0;

const int DC_IOCTL_SERIAL_SET_LATENCY = 2147775232;

const int SAMPLE_EVENT_UNKNOWN = 16;

const int DC_DIVEMODE_CC = 3;

const int DC_SENSOR_NONE = 4294967295;

const int DC_GASMIX_UNKNOWN = 4294967295;

const int DC_IOCTL_USB_CONTROL_READ = 1073771776;

const int DC_IOCTL_USB_CONTROL_WRITE = 2147513600;

const int DC_IOCTL_BLE_GET_NAME = 1073766912;

const int DC_BLUETOOTH_SIZE = 18;
